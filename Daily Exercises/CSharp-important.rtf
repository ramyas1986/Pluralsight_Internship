{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 ArialMT;\f1\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;\red199\green199\blue224;
}
{\*\expandedcolortbl;;\cssrgb\c0\c0\c0;\cssrgb\c100000\c100000\c100000;\cssrgb\c81961\c82353\c90196;
}
\paperw11900\paperh16840\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf2 \cb3 StringBuilder:
\f1\fs24 \
\
\pard\pardeftab720\partightenfactor0

\f0\fs28 \cf2 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec4 I mentioned there were two things that I couldn't explain to you before we knew about reference types. The second one is what we'll look at now, the fact that the string type is, in fact, a reference type, too. Let's start again with a small snippet of code here. Say that we have a string that contains Hello. I then create a new string b and I set it equal to a. Then, in the next line, I add to b using +=, space, world. Then we ask to see what a is. The result is Hello. Can you figure out, based on what we already saw when I'm talking about reference types, what happened here? Strings are very foundational concepts in C#, but unlike int, float, and char, they are not value types. They're reference types. They point to the actual string in\uc0\u8209 memory, so on the heap. I'm going to show you in a diagram what has happened, and then this will already become a lot clearer. So first, you create a and b, and a will contain Hello. A points to the string Hello. That's important here. Now, we set b equal to a. B doesn't contain a copy; it just points to the same memory location as a. Now we create a new string, space, world. And then I set b to the concatenated version of what it currently contains, plus this new string. Notice what now happened. B, and b only, points to the newly created string. A doesn't know about all this. It is just still happily pointing to the original Hello string. That is because strings are reference types. They aren't created on the stack, they are created on the heap. That's another thing to notice here. When we created this new string, space world, and suffixed b with it, an entirely new string was created. The original wasn't changed. This is because strings are immutable. Once created, a string cannot be changed. Now, you may be thinking, hey, we saw earlier that we could, for example, replace a character within a string with a new one. Surely then we are changing the original string, aren't we? Well, I must disappoint you. Every operation you do on a string will result in a new one being created. So also your replace operation will return a new string with the values replaced. Now, why am I telling you this? Is this important? Well, yes and no. No, because, in fact, C# handles all this. It'll return a new string for you, and if needed, it'll clean up the old string for you, too. But doesn't all this copying and creating of new strings have an impact on performance? Well, that would, or maybe I should say, could be the case. In regular circumstance, by no means, do you really need to worry. C# will handle this for you. But say you are doing some string operations inside of a loop or you're doing a lot of concatenation operations. This could result in a lot of strings being copied over and have a negative impact on performance for your application. Time to start worrying? Absolutely not. C# has a solution on board, and it's called the string builder. As its name gives away, it is used to build strings, but in a more performant way without all the copying. So if you find yourself in a situation where you need to concatenate a lot of strings for which each individual operation would result in a string being copied, the string builder will be worth its name in gold. Take a look at the snippet you see here on the slide. I'm creating a new stringBuilder using the new keyword. Indeed, that's a type, and we're using the constructor. Then on my new stringBuilder, I'm calling the Append method to append the passed in string. I'll do that a few times using AppendLine, which will append the string and passing in on a new line. Using the stringBuilder, none of this will result in the string being copied over multiple times, which would be the case for regular strings. Finally, I can ask the stringBuilder to give me back the actual string value, and we can do so using the ToString method on a stringBuilder instance.\'a0\
\
\
\pard\pardeftab720\sa300\partightenfactor0

\fs34\fsmilli17143 \cf2 \strokec4 Demo: Creating a Unit Test\
\pard\pardeftab720\sa800\partightenfactor0

\fs28 \cf2 In the final demo of this module, we will go and create our first unit test. We'll start with the creation of a unit test project, and then we'll write a unit test. We'll then trigger it using Test Explorer. We are going to write our first unit test now. Now, unit test is code that is going to test auto code. So in our case, we're going to write unit test for our Employee class for these two methods here, these two methods I want to test. All right, let's do this. And since they will contain code, we need to write a class somewhere. As I said, the unit tests will live in a separate project. I hope you remember that this is our project, and the project is part of the solution. The solution is the container for one or more projects that work together. The unit test project is therefore also going to be part of the solution. So I can right\uc0\u8209 click on this solution and say Add, New Project. That is going to be a unit testing , s in this visit here to add a new project to the solution, I can search for units, making sure that C# is still selected, and then I get a couple of options. Different unit testing frameworks exist and Visual Studio supports most of these. I typically tend to use the xUnit testing projects for the xUnit testing framework. So I'm going to select that. I'm also going to give this project a name. Typically I give the same name as the main project suffixed with .tests. That's a good name to indicate that this project will indeed contain tests. And of course, this is going to be .NET 8 as well. It is going to contain code, and it's going to be also .NET 8 code. At this point, the unit testing project has been created, and it's going to contain tests for code in our main project. So I'm going to have to write code that uses code that lives in my main project. In order to be able to access that, I'm going to have to create a reference. We've already used references. But this time I'm going to create a project reference from this project to the main project. I'm going to right\u8209 click here on Dependencies and say Add Project Reference. In that dialog under Projects, I'll select BethanysPieShopHRM. That's our main project in the solution. I'll click OK. And now if you look, you will see here on the project that the reference to the main project has been created. By the way, if you expand Packages here, you'll see, amongst others, that xUnit is in there. Indeed xUnit is, in fact, nothing more than a NuGet package that is added to this project, and it was added by the template by executing that your own Visual Studio. Now, what the template also did was creating this class already UnitTest1. This will contain our tests. This will contain code that tests code in the main project. I'm going to write a few unit tests for the Employee class. So, a good idea is then to also name this EmployeeTests, as it gives away that this will contain tests for my Employee class. All right, let's go to our Employee type for now. And as said, unit tests will test small bits of good, small amounts of code. Typically, the smallest bit of code that we can invoke is a method. We can invoke a method from pretty much everywhere when we create in this case, an Employee instance, so I'm going to test here PerformWork. That's the method I want to test first. Now what does PerformWork do? Well, it accepts a number of hours, that's a parameter, and it will then increase the number of hours worked stored on my object with the number of hours passed in. In other words, if I want to write a test for this method, what I need to check is that this calculation actually works fine, that the NumberOfHoursWorked after executing this method is indeed the sum of the old numberOfHoursWorked, plus the passed in one. That's what I'm going to test here. So let's write our first unit test together. This is a test method, and the unit test is, in fact, nothing more than a method. I need to give it the name that describes very well what this test will do. Well, under Employee, I'm going to call the PerformWork method, and I'm going to test that it adds correctly the NumberOfHours. So what I'm doing here is I'm giving this method a name that describes what this test, what this method will actually do, and it will test PerformWork, and it will check that the NumberOfHours adding works fine. Now, one thing that we haven't looked at is this Fact between square brackets. Now this is what is known as an attribute, and this is needed for the unit testing framework, so for xUnit to pick up on this test, so it knows that a test is coming. Now, in my unit test, as mentioned, I'm going to have to follow the triple A, or the AAA approach. First, I'm going to arrange, then I'm going to act, and then I'm going to assert. What am I going to arrange here? Well, I'm actually going to work with employees, so that is definitely a piece of the setup, that is a piece of the arrangement I need to do. So let us start with creating a new employee. I'm getting a red squiggly. And also, as you can see here, it doesn't say bring in just a using statement. Why is that? Well, something must be wrong on an Employee class. Let's take a look. While the Employee class is set to internal, classes which are internal are only available within the assembly, so within this project, if I need to test this, I need to make this public, so an external project can also work with this. So I need to make this a public class. When I go back to my unit testing project, I go to my little light bulb here. I can now bring in a using statement, and that will make employee known in my unit test. So I'm going to write here Employee employee is a new Employee, passing in some data here. Also, DateTime isn't known here. Let's use the light bulb again to bring in system. There we go. So now we have our Employee. Let's go back to the Employee for just a second. Now, first, I do notice here a red squiggly. Address is complaining. Why is that? Well, it is because this class is also internal, and it's now used from a public class that also at least needs to be public. So I need to change that. And that's not what I wanted to talk about. I actually wanted to talk a bit more about PerformWork. Now, PerformWork also requires NumberOfHours, and that's a parameter that we need to pass in. And that is still part of the setup, part of the arrange. I'm going to set the numberOfHours to 3. I'm just creating a local variable numberOfHours, and I set it to 3. Now, this is hard\u8209 coded. I'll use that later on in my assert to see if the result is okay. Now I'm going to act. Now I'm going to invoke the code I really want to test. Now, what do I want to test? Th employee.PerformWork, passing in the numberOfHours. Now, initially, numberOfHours for an employee was guaranteed to be 0. Because it's a new employee, we expect that to have no worked hours yet. Now I PerformWork, and that takes in this 3. Now in the assert, I'm then going to check if the code behaves correctly so that the total numberOfHours worked for the employee should be equal to what we have passed in here, numberOfHours. That I can do indeed using an Assert. Using Assert.Equal, I can test that the numberOfHours here is equal to the employee.NumberOfHoursWorked. That is the value that is going to be influenced over here on the employee. So if that is equal to 3, after invoking this method, well, then my test will get a green light. Let me add another unit test and take you through it. And take a look at the name. I've called this method PerformWork_Adds_DefaultNumberOfHours._IfNoValueSpecified. In other words, I'm just going to call the PerformWork method on an employee, and then in my assert, I'm going to check that the numberOfHoursWorked for that employee is equal to 1. One, of course, coming from that constant value defined on employee. So I'm going to test that the numberOfHoursWorked on the employee is after a single call to PerformSork set to 1. Those are my two unit tests. Now, we need to run these tests. Now, for that we can go to Test, and then we can click here on Run All Tests.That will open the Test Explorer. The code is compiled, and we indeed get a green light. We have two unit tests that passed successfully. If we now make a change, let's say that we go to employee and we make a mistake here. We increase the numberOfHoursWorked with 1. We've made a change to the functionality, and we probably have broken something. Our unit test can now tell us that. Unit test can now be seen as a signal to quickly let us know that we've made a change that changes the behavior of this code. If we go again to Test, Run All Tests, the test will run again, and notice what happened now. We're getting red lights. This is now a signal for me that I've broken the code, that I've changed the functionality, and the code isn't behaving as it did before anymore. I need to go back and inspect what changes I've made. This is how unit test will alert you that you've made breaking changes to the behavior of your code.\
}